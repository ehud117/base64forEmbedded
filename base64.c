#include <stdio.h>
#include <string.h>

struct BinaryData {
	unsigned char data[1024];
	int length;
};
// 
const char encodeMap[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

const char decodeMap[256] = {
'*', /* 0   - 	*/
'*', /* 1   - */
'*', /* 2   - */
'*', /* 3   - */
'*', /* 4   - */
'*', /* 5   - */
'*', /* 6   - */
'*', /* 7   - */
'*', /* 8   - */
'*', /* 9   - */
'*', /* 10  - */
'*', /* 11  - */
'*', /* 12  - */
'*', /* 13  - */
'*', /* 14  - */
'*', /* 15  - */
'*', /* 16  - */
'*', /* 17  - */
'*', /* 18  - */
'*', /* 19  - */
'*', /* 20  - */
'*', /* 21  - */
'*', /* 22  - */
'*', /* 23  - */
'*', /* 24  - */
'*', /* 25  - */
'*', /* 26  - */
'*', /* 27  - */
'*', /* 28  - */
'*', /* 29  - */
'*', /* 30  - */
'*', /* 31  - */
'*', /* 32  -  	*/
'*', /* 33  - !	*/
'*', /* 34  - '	*/
'*', /* 35  - #	*/
'*', /* 36  - $	*/
'*', /* 37  - %	*/
'*', /* 38  - &	*/
'*', /* 39  - '	*/
'*', /* 40  - (	*/
'*', /* 41  - )	*/
'*', /* 42  - *	*/
62, /* 43  - +	*/
'*', /* 44  - ,	*/
'*', /* 45  - -	*/
'*', /* 46  - .	*/
63, /* 47  - /	*/
52, /* 48  - 0	*/
53, /* 49  - 1	*/
54, /* 50  - 2	*/
55, /* 51  - 3	*/
56, /* 52  - 4	*/
57, /* 53  - 5	*/
58, /* 54  - 6	*/
59, /* 55  - 7	*/
60, /* 56  - 8	*/
61, /* 57  - 9	*/
'*', /* 58  - :	*/
'*', /* 59  - ;	*/
'*', /* 60  - <	*/
'*', /* 61  - =	*/
'*', /* 62  - >	*/
'*', /* 63  - ?	*/
'*', /* 64  - @	*/
0, /* 65  - A	*/
1, /* 66  - B	*/
2, /* 67  - C	*/
3, /* 68  - D	*/
4, /* 69  - E	*/
5, /* 70  - F	*/
6, /* 71  - G	*/
7, /* 72  - H	*/
8, /* 73  - I	*/
9, /* 74  - J	*/
10, /* 75  - K	*/
11, /* 76  - L	*/
12, /* 77  - M	*/
13, /* 78  - N	*/
14, /* 79  - O	*/
15, /* 80  - P	*/
16, /* 81  - Q	*/
17, /* 82  - R	*/
18, /* 83  - S	*/
19, /* 84  - T	*/
20, /* 85  - U	*/
21, /* 86  - V	*/
22, /* 87  - W	*/
23, /* 88  - X	*/
24, /* 89  - Y	*/
25, /* 90  - Z	*/
'*', /* 91  - [	*/
'*', /* 92  - \	*/
'*', /* 93  - ]	*/
'*', /* 94  - ^	*/
'*', /* 95  - _	*/
'*', /* 96  - `	*/
26, /* 97  - a	*/
27, /* 98  - b	*/
28, /* 99  - c	*/
29, /* 100 - d	*/
30, /* 101 - e	*/
31, /* 102 - f	*/
32, /* 103 - g	*/
33, /* 104 - h	*/
34, /* 105 - i	*/
35, /* 106 - j	*/
36, /* 107 - k	*/
37, /* 108 - l	*/
38, /* 109 - m	*/
39, /* 110 - n	*/
40, /* 111 - o	*/
41, /* 112 - p	*/
42, /* 113 - q	*/
43, /* 114 - r	*/
44, /* 115 - s	*/
45, /* 116 - t	*/
46, /* 117 - u	*/
47, /* 118 - v	*/
48, /* 119 - w	*/
49, /* 120 - x	*/
50, /* 121 - y	*/
51, /* 122 - z	*/
'*', /* 123 - {	*/
'*', /* 124 - |	*/
'*', /* 125 - }	*/
'*', /* 126 - ~	*/
'*', /* 127 - 	*/
'*', /* 128 - Ä	*/
'*', /* 129 - Å	*/
'*', /* 130 - Ç	*/
'*', /* 131 - É	*/
'*', /* 132 - Ñ	*/
'*', /* 133 - Ö	*/
'*', /* 134 - Ü	*/
'*', /* 135 - á	*/
'*', /* 136 - à	*/
'*', /* 137 - â	*/
'*', /* 138 - ä	*/
'*', /* 139 - ã	*/
'*', /* 140 - å	*/
'*', /* 141 - ç	*/
'*', /* 142 - é	*/
'*', /* 143 - è	*/
'*', /* 144 - ê	*/
'*', /* 145 - ë	*/
'*', /* 146 - í	*/
'*', /* 147 - ì	*/
'*', /* 148 - î	*/
'*', /* 149 - ï	*/
'*', /* 150 - ñ	*/
'*', /* 151 - ó	*/
'*', /* 152 - ò	*/
'*', /* 153 - ô	*/
'*', /* 154 - ö	*/
'*', /* 155 - õ	*/
'*', /* 156 - ú	*/
'*', /* 157 - ù	*/
'*', /* 158 - û	*/
'*', /* 159 - ü	*/
'*', /* 160 - †	*/
'*', /* 161 - °	*/
'*', /* 162 - ¢	*/
'*', /* 163 - £	*/
'*', /* 164 - §	*/
'*', /* 165 - •	*/
'*', /* 166 - ¶	*/
'*', /* 167 - ß	*/
'*', /* 168 - ®	*/
'*', /* 169 - ©	*/
'*', /* 170 - ™	*/
'*', /* 171 - ´	*/
'*', /* 172 - ¨	*/
'*', /* 173 - ≠	*/
'*', /* 174 - Æ	*/
'*', /* 175 - Ø	*/
'*', /* 176 - ∞	*/
'*', /* 177 - ±	*/
'*', /* 178 - ≤	*/
'*', /* 179 - ≥	*/
'*', /* 180 - ¥	*/
'*', /* 181 - µ	*/
'*', /* 182 - ∂	*/
'*', /* 183 - ∑	*/
'*', /* 184 - ∏	*/
'*', /* 185 - π	*/
'*', /* 186 - ∫	*/
'*', /* 187 - ª	*/
'*', /* 188 - º	*/
'*', /* 189 - Ω	*/
'*', /* 190 - æ	*/
'*', /* 191 - ø	*/
'*', /* 192 - ¿	*/
'*', /* 193 - ¡	*/
'*', /* 194 - ¬	*/
'*', /* 195 - √	*/
'*', /* 196 - ƒ	*/
'*', /* 197 - ≈	*/
'*', /* 198 - ∆	*/
'*', /* 199 - «	*/
'*', /* 200 - »	*/
'*', /* 201 - …	*/
'*', /* 202 -  	*/
'*', /* 203 - À	*/
'*', /* 204 - Ã	*/
'*', /* 205 - Õ	*/
'*', /* 206 - Œ	*/
'*', /* 207 - œ	*/
'*', /* 208 - –	*/
'*', /* 209 - —	*/
'*', /* 210 - “	*/
'*', /* 211 - ”	*/
'*', /* 212 - ‘	*/
'*', /* 213 - ’	*/
'*', /* 214 - ÷	*/
'*', /* 215 - ◊	*/
'*', /* 216 - ÿ	*/
'*', /* 217 - Ÿ	*/
'*', /* 218 - ⁄	*/
'*', /* 219 - €	*/
'*', /* 220 - ‹	*/
'*', /* 221 - ›	*/
'*', /* 222 - ﬁ	*/
'*', /* 223 - ﬂ	*/
'*', /* 224 - ‡	*/
'*', /* 225 - ·	*/
'*', /* 226 - ‚	*/
'*', /* 227 - „	*/
'*', /* 228 - ‰	*/
'*', /* 229 - Â	*/
'*', /* 230 - Ê	*/
'*', /* 231 - Á	*/
'*', /* 232 - Ë	*/
'*', /* 233 - È	*/
'*', /* 234 - Í	*/
'*', /* 235 - Î	*/
'*', /* 236 - Ï	*/
'*', /* 237 - Ì	*/
'*', /* 238 - Ó	*/
'*', /* 239 - Ô	*/
'*', /* 240 - 	*/
'*', /* 241 - Ò	*/
'*', /* 242 - Ú	*/
'*', /* 243 - Û	*/
'*', /* 244 - Ù	*/
'*', /* 245 - ı	*/
'*', /* 246 - ˆ	*/
'*', /* 247 - ˜	*/
'*', /* 248 - ¯	*/
'*', /* 249 - ˘	*/
'*', /* 250 - ˙	*/
'*', /* 251 - ˚	*/
'*', /* 252 - ¸	*/
'*', /* 253 - ˝	*/
'*', /* 254 - ˛	*/
'*' /* 255 - ˇ	*/
};

// 8 7 6 5 4 3 2 1|8 7 6 5 4 3 2 1|8 7 6 5 4 3 2 1
// 6 5 4 3 2 1|6 5 4 3 2 1|6 5 4 3 2 1|6 5 4 3 2 1

void btoa(const struct BinaryData binary, char *base64) {
	int i, b1, b2, b3;
	for (i = 0; i < 3 * (binary.length / 3); i += 3) {
		b1 = binary.data[i];
		b2 = binary.data[i + 1];
		b3 = binary.data[i + 2];
		*base64++ = encodeMap[b1 >> 2];
		*base64++ = encodeMap[((b1 & 0x3) << 4) + (b2 >> 4)];
		*base64++ = encodeMap[((b2 & 0xf) << 2) + (b3 >> 6)];
		*base64++ = encodeMap[b3 & 63];
	}
	if (binary.length % 3 != 0) {
		b1 = binary.data[i];
		*base64++ = encodeMap[b1 >> 2];
		if (binary.length % 3 == 1) {
			*base64++ = encodeMap[((b1 & 0x3) << 4)];
			*base64++ = '=';
			*base64++ = '=';
		} else {
			b2 = binary.data[i + 1];
			*base64++ = encodeMap[((b1 & 0x3) << 4) + (b2 >> 4)];
			*base64++ = encodeMap[((b2 & 0xf) << 2)];
			*base64++ = '=';
		}
	}	
	*base64 = '\0';
}

// 8 7 6 5 4 3 2 1|8 7 6 5 4 3 2 1|8 7 6 5 4 3 2 1
// 6 5 4 3 2 1|6 5 4 3 2 1|6 5 4 3 2 1|6 5 4 3 2 1

#ifdef VALIDATE_INPUT
static void validateBase64(char *b64) {
	char *pStart = b64;
	for (; *b64; b64++) // Assert all input chars valid.
		assert(memchr(encodeMap, *b64, 64) || 
			(*b64 == '=' && b64[1] == '=' && b64[2] == '\0') ||
			(*b64 == '=' && b64[1] == '\0'));
	
	// Assert input length is a muliple of 4
	int len = p64 - pStart;
	assert((len % 4) == 0);
}
#endif
 
#pragma GCC diagnostic ignored "-Wchar-subscripts"
void atob(const char *base64, struct BinaryData *binary) {
#ifdef VALIDATE_INPUT
	validateBase64(base64);
#endif
	
	int i, base64Len = strlen(base64);
	int o1, o2, o3, o4;
	
	int safeRange; // For a fast run on without warring about '=' chars
	if (base64[base64Len - 1] == '=')
		safeRange = base64Len - 4;
	else
		safeRange = base64Len;
	
	binary->length = 0;
	for (i = 0; i < safeRange; i += 4) { 
		o1 = decodeMap[base64[i]];
		o2 = decodeMap[base64[i + 1]];
		o3 = decodeMap[base64[i + 2]];
		o4 = decodeMap[base64[i + 3]];
		
		binary->data[binary->length++] = (o1 << 2) + (o2 >> 4);
		binary->data[binary->length++] = ((o2 & 0xf) << 4) + (o3 >> 2);
		binary->data[binary->length++] = ((o3 & 0x3) << 6) + o4;
	}
	
	if (base64[base64Len - 1] == '=') {
		o1 = decodeMap[base64[i]];
		o2 = decodeMap[base64[i + 1]];
		binary->data[binary->length++] = (o1 << 2) + (o2 >> 4);
		if (base64[base64Len - 2] != '=') {
			o3 = decodeMap[base64[i + 2]];
			binary->data[binary->length++] = ((o2 & 0xf) << 4) + (o3 >> 2);
		}
	}
}

static struct BinaryData binaryData;
static char ascii[4 * 1024 / 3 + 4 + 1]; 

static void testString(const char *s) {
	// Copy input to binary data
	strcpy((char *)binaryData.data, s);
	binaryData.length = strlen(s);
	// Convert to base 64
	btoa(binaryData, ascii);
	// Print result
	printf("btoa('%s') = %s\n", s, ascii);
	
	// Zero binary data
	memset(&binaryData, 0, sizeof(binaryData));
	// Convert base 64 to binary.
	atob(ascii, &binaryData);
	printf("length is %d\n", binaryData.length);
	binaryData.data[binaryData.length] = '\0';
	printf("atob('%s') = %s\n", ascii, binaryData.data);
	printf("=============================\n");
}

int main() {
	
	testString("a");
	testString("ab");
	testString("abc");
	testString("abcd");
	
}
